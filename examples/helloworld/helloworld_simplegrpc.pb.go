// Code generated by protoc-gen-go-simple-grpc DO NOT EDIT.
package helloworld

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net/http"
	"path"
	"strconv"
	"strings"
	"unicode/utf8"

	"github.com/bakins/simplegrpc"
	"google.golang.org/protobuf/proto"
)

const (
	spaceByte   = ' '
	tildeByte   = '~'
	percentByte = '%'
)

func encodeGrpcMessage(msg string) string {
	if msg == "" {
		return ""
	}
	lenMsg := len(msg)
	for i := 0; i < lenMsg; i++ {
		c := msg[i]
		if !(c >= spaceByte && c <= tildeByte && c != percentByte) {
			return encodeGrpcMessageUnchecked(msg)
		}
	}
	return msg
}

func encodeGrpcMessageUnchecked(msg string) string {
	var buf bytes.Buffer
	for len(msg) > 0 {
		r, size := utf8.DecodeRuneInString(msg)
		for _, b := range []byte(string(r)) {
			if size > 1 {
				// If size > 1, r is not ascii. Always do percent encoding.
				buf.WriteString(fmt.Sprintf("%%%02X", b))
				continue
			}

			// The for loop is necessary even if size == 1. r could be
			// utf8.RuneError.
			//
			// fmt.Sprintf("%%%02X", utf8.RuneError) gives "%FFFD".
			if b >= spaceByte && b <= tildeByte && b != percentByte {
				buf.WriteByte(b)
			} else {
				buf.WriteString(fmt.Sprintf("%%%02X", b))
			}
		}
		msg = msg[size:]
	}
	return buf.String()
}

type GreeterGRPCService interface {
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
}

type GreeterGRPCHandler interface {
	http.Handler
	PathPrefix() string
}

type GreeterGRPCServer struct {
	implementation GreeterGRPCService
	interceptor    simplegrpc.Interceptor
	codecs         map[string]simplegrpc.Codec
	handlers       map[string]http.Handler
	pathPrefix     string
}

var _ GreeterGRPCHandler = &GreeterGRPCServer{}

func NewGreeterGRPCServer(implementation GreeterGRPCService, opts ...simplegrpc.ServerOption) *GreeterGRPCServer {
	serverOpts := simplegrpc.ServerOptions{}

	for _, o := range opts {
		o(&serverOpts)
	}

	panicInterceptor := func(method simplegrpc.Method) simplegrpc.Method {
		return func(ctx context.Context, request interface{}) (resp interface{}, err error) {
			defer func() {
				if r := recover(); r != nil {
					perr, ok := r.(error)
					if !ok {
						perr = fmt.Errorf("panic: %v", perr)
					}

					err = simplegrpc.NewError(simplegrpc.Internal, perr.Error())

				}
			}()

			resp, err = method(ctx, request)
			return resp, err
		}
	}

	contextInterceptor := func(method simplegrpc.Method) simplegrpc.Method {
		return func(ctx context.Context, request interface{}) (interface{}, error) {
			resp, err := method(ctx, request)

			if err != nil {
				if errors.Is(err, context.Canceled) {
					return nil, simplegrpc.NewError(simplegrpc.Canceled, "context cancelled")
				}

				if errors.Is(err, context.DeadlineExceeded) {
					return nil, simplegrpc.NewError(simplegrpc.DeadlineExceeded, "context deadline exceeded")
				}

				return nil, err
			}

			return resp, nil
		}
	}

	interceptors := []simplegrpc.Interceptor{
		panicInterceptor,
		contextInterceptor,
	}

	interceptors = append(interceptors, serverOpts.Interceptors...)

	protoErr := errors.New("message is not a proto.")
	protobufCodec := simplegrpc.ToCodec(
		"proto",
		func(ctx context.Context, v interface{}) ([]byte, error) {
			m, ok := v.(proto.Message)
			if !ok {
				return nil, protoErr
			}
			return proto.MarshalOptions{}.Marshal(m)
		},
		func(ctx context.Context, data []byte, v interface{}) error {
			m, ok := v.(proto.Message)
			if !ok {
				return protoErr
			}
			return proto.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(data, m)
		},
	)

	codecs := []simplegrpc.Codec{protobufCodec}
	codecs = append(codecs, serverOpts.Codecs...)

	s := &GreeterGRPCServer{
		implementation: implementation,
		interceptor:    simplegrpc.ChainInterceptors(interceptors...),
		codecs:         map[string]simplegrpc.Codec{},
		handlers:       map[string]http.Handler{},
		pathPrefix:     path.Clean(path.Join("/", "helloworld.Greeter")) + "/",
	}

	for _, c := range codecs {
		s.codecs[c.Name()] = c
	}

	s.handlers["SayHello"] = http.HandlerFunc(s.callSayHello)

	return s
}

func (s *GreeterGRPCServer) PathPrefix() string {
	return s.pathPrefix
}

// send an error with no body
func (s *GreeterGRPCServer) serveError(err error, w http.ResponseWriter, contentType string) {
	w.Header().Set("Content-Type", contentType)
	w.Header().Add("Trailer", "grpc-status, grpc-message")
	w.WriteHeader(http.StatusOK)

	g, ok := err.(simplegrpc.Error)
	if !ok {
		g = simplegrpc.NewError(simplegrpc.Internal, err.Error())
	}

	w.Header().Set("grpc-status", strconv.Itoa(int(g.Code())))
	w.Header().Set("grpc-message", encodeGrpcMessage(g.Message()))
}

func (s *GreeterGRPCServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	ctx := simplegrpc.WithPackageName(r.Context(), "helloworld")
	ctx = simplegrpc.WithServiceName(ctx, "Greeter")

	method := strings.TrimPrefix(r.URL.Path, s.pathPrefix)
	if method == "" {
		http.Error(w, "empty method name", http.StatusBadRequest)
		return
	}

	ctx = simplegrpc.WithMethodName(ctx, method)

	handler, ok := s.handlers[method]
	if !ok {
		http.Error(w, "no handler for method", http.StatusNotFound)
		return
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

func (s *GreeterGRPCServer) callSayHello(w http.ResponseWriter, r *http.Request) {
	subContentType := "proto"

	ct := r.Header.Get("Content-Type")
	if ct != "application/grpc" {
		if !strings.HasPrefix(ct, "application/grpc") {
			http.Error(w, "invalid content-type", http.StatusBadRequest)
			return
		}
		subContentType = strings.TrimPrefix(ct, "application/grpc+")
	}

	codec, ok := s.codecs[subContentType]
	if !ok {
		err := simplegrpc.Errorf(simplegrpc.Unimplemented, "unsupported codec %q", subContentType)
		s.serveError(err, w, ct)
		return
	}

	// does not support compression currently
	prefix := []byte{0, 0, 0, 0, 0}
	if _, err := io.ReadFull(r.Body, prefix); err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to read message prefix: %v", err)
		s.serveError(e, w, ct)
		return
	}

	// TODO: check for message too large

	length := binary.BigEndian.Uint32(prefix[1:])
	body := make([]byte, length)

	if _, err := io.ReadFull(r.Body, body); err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to read message: %v", err)
		s.serveError(e, w, ct)
		return
	}

	ctx := r.Context()
	reqContent := &HelloRequest{}

	if err := codec.Unmarshal(ctx, body, reqContent); err != nil {
		e := simplegrpc.Errorf(simplegrpc.InvalidArgument, "failed to unmarshal request body: %v", err)
		s.serveError(e, w, ct)
		return
	}

	handler := func(ctx context.Context, req *HelloRequest) (*HelloReply, error) {
		resp, err := s.interceptor(
			func(ctx context.Context, req interface{}) (interface{}, error) {
				typedReq, ok := req.(*HelloRequest)
				if !ok {
					return nil, simplegrpc.NewError(simplegrpc.Internal, "failed type assertion req.(*HelloRequest) when calling interceptor")
				}
				return s.implementation.SayHello(ctx, typedReq)
			},
		)(ctx, req)
		if resp != nil {
			typedResp, ok := resp.(*HelloReply)
			if !ok {
				return nil, simplegrpc.NewError(simplegrpc.Internal, "failed type assertion resp.(*HelloReply) when calling interceptor")
			}
			return typedResp, err
		}
		return nil, err
	}

	respContent, err := handler(ctx, reqContent)

	if respContent == nil && err == nil {
		e := simplegrpc.NewError(simplegrpc.Internal, "received a nil *HelloReply and nil error while calling SayHello. nil responses are not supported")
		s.serveError(e, w, ct)
		return
	}

	if err != nil {
		s.serveError(err, w, ct)
		return
	}

	// TODO: check for message too large
	respBytes, err := codec.Marshal(ctx, respContent)
	if err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to unmarshal request body: %v", err)
		s.serveError(e, w, ct)
		return
	}

	// does not support compression currently
	prefix = []byte{0, 0, 0, 0, 0}
	binary.BigEndian.PutUint32(prefix[1:], uint32(len(respBytes)))

	w.Header().Set("Content-Type", ct)
	w.Header().Add("Trailer", "grpc-status, grpc-message")
	w.WriteHeader(http.StatusOK)

	if _, err := w.Write(prefix); err != nil {
		fmt.Println("failed to write prefix", err)
		return
	}

	if _, err := w.Write(respBytes); err != nil {
		fmt.Println("failed to write message", err)
		return
	}

	w.Header().Set("grpc-status", "0")
	w.Header().Set("grpc-message", "OK")
}
