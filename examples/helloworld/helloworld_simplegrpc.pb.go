// Code generated by protoc-gen-go-simple-grpc DO NOT EDIT.
package helloworld

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"path"
	"strconv"
	"strings"
	"unicode/utf8"

	"github.com/bakins/simplegrpc"
	"google.golang.org/protobuf/proto"
)

const (
	spaceByte   = ' '
	tildeByte   = '~'
	percentByte = '%'
)

func encodeGrpcMessage(msg string) string {
	if msg == "" {
		return ""
	}
	lenMsg := len(msg)
	for i := 0; i < lenMsg; i++ {
		c := msg[i]
		if !(c >= spaceByte && c <= tildeByte && c != percentByte) {
			return encodeGrpcMessageUnchecked(msg)
		}
	}
	return msg
}

func encodeGrpcMessageUnchecked(msg string) string {
	var buf bytes.Buffer
	for len(msg) > 0 {
		r, size := utf8.DecodeRuneInString(msg)
		for _, b := range []byte(string(r)) {
			if size > 1 {
				// If size > 1, r is not ascii. Always do percent encoding.
				buf.WriteString(fmt.Sprintf("%%%02X", b))
				continue
			}

			// The for loop is necessary even if size == 1. r could be
			// utf8.RuneError.
			//
			// fmt.Sprintf("%%%02X", utf8.RuneError) gives "%FFFD".
			if b >= spaceByte && b <= tildeByte && b != percentByte {
				buf.WriteByte(b)
			} else {
				buf.WriteString(fmt.Sprintf("%%%02X", b))
			}
		}
		msg = msg[size:]
	}
	return buf.String()
}

type GreeterGRPCService interface {
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
}

type GreeterGRPCHandler interface {
	http.Handler
	PathPrefix() string
}

type GreeterGRPCServer struct {
	implementation GreeterGRPCService
	interceptor    simplegrpc.Interceptor
	handlers       map[string]http.Handler
	pathPrefix     string
}

var _ GreeterGRPCHandler = &GreeterGRPCServer{}

func NewGreeterGRPCServer(implementation GreeterGRPCService, opts ...simplegrpc.ServerOption) *GreeterGRPCServer {
	serverOpts := simplegrpc.ServerOptions{}

	for _, o := range opts {
		o(&serverOpts)
	}

	panicInterceptor := func(method simplegrpc.Method) simplegrpc.Method {
		return func(ctx context.Context, request interface{}) (resp interface{}, err error) {
			defer func() {
				if r := recover(); r != nil {
					perr, ok := r.(error)
					if !ok {
						perr = fmt.Errorf("panic: %v", perr)
					}

					err = simplegrpc.NewError(simplegrpc.Internal, perr.Error())

				}
			}()

			resp, err = method(ctx, request)
			return resp, err
		}
	}

	contextInterceptor := func(method simplegrpc.Method) simplegrpc.Method {
		return func(ctx context.Context, request interface{}) (interface{}, error) {
			resp, err := method(ctx, request)

			if err != nil {
				if errors.Is(err, context.Canceled) {
					return nil, simplegrpc.NewError(simplegrpc.Canceled, "context cancelled")
				}

				if errors.Is(err, context.DeadlineExceeded) {
					return nil, simplegrpc.NewError(simplegrpc.DeadlineExceeded, "context deadline exceeded")
				}

				return nil, err
			}

			return resp, nil
		}
	}

	interceptors := []simplegrpc.Interceptor{
		panicInterceptor,
		contextInterceptor,
	}

	interceptors = append(interceptors, serverOpts.Interceptors...)

	s := &GreeterGRPCServer{
		implementation: implementation,
		interceptor:    simplegrpc.ChainInterceptors(interceptors...),
		handlers:       map[string]http.Handler{},
		pathPrefix:     path.Clean(path.Join("/", "helloworld.Greeter")) + "/",
	}

	s.handlers["SayHello"] = http.HandlerFunc(s.callSayHello)

	return s
}

func (s *GreeterGRPCServer) PathPrefix() string {
	return s.pathPrefix
}

// send an error with no body
func (s *GreeterGRPCServer) serveError(err error, w http.ResponseWriter, contentType string) {
	w.Header().Set("Content-Type", contentType)
	w.Header().Add("Trailer", "grpc-status, grpc-message")
	w.WriteHeader(http.StatusOK)

	g, ok := err.(simplegrpc.Error)
	if !ok {
		g = simplegrpc.NewError(simplegrpc.Internal, err.Error())
	}

	w.Header().Set("grpc-status", strconv.Itoa(int(g.Code())))
	w.Header().Set("grpc-message", encodeGrpcMessage(g.Message()))
}

func (s *GreeterGRPCServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	ctx := simplegrpc.WithPackageName(r.Context(), "helloworld")
	ctx = simplegrpc.WithServiceName(ctx, "Greeter")

	method := strings.TrimPrefix(r.URL.Path, s.pathPrefix)
	if method == "" {
		http.Error(w, "empty method name", http.StatusBadRequest)
		return
	}

	ctx = simplegrpc.WithMethodName(ctx, method)

	handler, ok := s.handlers[method]
	if !ok {
		http.Error(w, "no handler for method", http.StatusNotFound)
		return
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

func (s *GreeterGRPCServer) callSayHello(w http.ResponseWriter, r *http.Request) {
	ct := r.Header.Get("Content-Type")

	switch ct {
	case "application/grpc", "application/grpc+proto":
	default:
		e := simplegrpc.Errorf(simplegrpc.Unimplemented, "unsupported content-type %q", ct)
		s.serveError(e, w, ct)
		return
	}

	// does not support compression currently
	prefix := []byte{0, 0, 0, 0, 0}
	if _, err := io.ReadFull(r.Body, prefix); err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to read message prefix: %v", err)
		s.serveError(e, w, ct)
		return
	}

	// TODO: check for message too large

	length := binary.BigEndian.Uint32(prefix[1:])
	body := make([]byte, length)

	if _, err := io.ReadFull(r.Body, body); err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to read message: %v", err)
		s.serveError(e, w, ct)
		return
	}

	ctx := r.Context()
	reqContent := &HelloRequest{}

	u := proto.UnmarshalOptions{DiscardUnknown: true}
	if err := u.Unmarshal(body, reqContent); err != nil {
		e := simplegrpc.Errorf(simplegrpc.InvalidArgument, "failed to unmarshal request body: %v", err)
		s.serveError(e, w, ct)
		return
	}

	handler := func(ctx context.Context, req *HelloRequest) (*HelloReply, error) {
		resp, err := s.interceptor(
			func(ctx context.Context, req interface{}) (interface{}, error) {
				typedReq, ok := req.(*HelloRequest)
				if !ok {
					return nil, simplegrpc.NewError(simplegrpc.Internal, "failed type assertion req.(*HelloRequest) when calling interceptor")
				}
				return s.implementation.SayHello(ctx, typedReq)
			},
		)(ctx, req)
		if resp != nil {
			typedResp, ok := resp.(*HelloReply)
			if !ok {
				return nil, simplegrpc.NewError(simplegrpc.Internal, "failed type assertion resp.(*HelloReply) when calling interceptor")
			}
			return typedResp, err
		}
		return nil, err
	}

	respContent, err := handler(ctx, reqContent)

	if respContent == nil && err == nil {
		e := simplegrpc.NewError(simplegrpc.Internal, "received a nil *HelloReply and nil error while calling SayHello. nil responses are not supported")
		s.serveError(e, w, ct)
		return
	}

	if err != nil {
		s.serveError(err, w, ct)
		return
	}

	// TODO: check for message too large
	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to unmarshal request body: %v", err)
		s.serveError(e, w, ct)
		return
	}

	// does not support compression currently
	prefix = []byte{0, 0, 0, 0, 0}
	binary.BigEndian.PutUint32(prefix[1:], uint32(len(respBytes)))

	w.Header().Set("Content-Type", ct)
	w.Header().Add("Trailer", "grpc-status, grpc-message")
	w.WriteHeader(http.StatusOK)

	if _, err := w.Write(prefix); err != nil {
		fmt.Println("failed to write prefix", err)
		return
	}

	if _, err := w.Write(respBytes); err != nil {
		fmt.Println("failed to write message", err)
		return
	}

	w.Header().Set("grpc-status", "0")
	w.Header().Set("grpc-message", "OK")
}

type GreeterGRPCClient struct {
	interceptor simplegrpc.Interceptor
	client      *http.Client
	request     *http.Request
}

func NewGreeterGRPCClient(endpoint string, transport http.RoundTripper) (*GreeterGRPCClient, error) {
	if transport == nil {
		transport = http.DefaultTransport
	}

	client := http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
		Transport: transport,
	}

	request, err := http.NewRequest(http.MethodPost, endpoint, nil)
	if err != nil {
		return nil, err
	}

	c := GreeterGRPCClient{
		client:  &client,
		request: request,
	}

	return &c, nil
}

func (s *GreeterGRPCClient) SayHello(ctx context.Context, input *HelloRequest) (*HelloReply, error) {
	request := s.request.Clone(ctx)
	request.ContentLength = -1

	body, err := proto.Marshal(input)
	if err != nil {
		return nil, err
	}

	// does not support compression currently
	prefix := []byte{0, 0, 0, 0, 0}
	binary.BigEndian.PutUint32(prefix[1:], uint32(len(body)))

	buff := bytes.NewBuffer(nil)
	buff.Grow(len(prefix) + len(body))

	if _, err := buff.Write(prefix); err != nil {
		return nil, err
	}

	if _, err := buff.Write(body); err != nil {
		return nil, err
	}

	request.Body = ioutil.NopCloser(buff)

	resp, err := s.client.Do(request)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		// TODO: read some of the body for the error
		return nil, fmt.Errorf("unexpected HTTP status code %d", resp.StatusCode)
	}

	//check header for status
	// read body
	// check trailer

	return nil, nil
}
