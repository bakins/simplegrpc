// Code generated by protoc-gen-go-simple-grpc DO NOT EDIT.
package {{ .Package }}

import (
	"bytes"
	"context"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"path"
	"strconv"
	"strings"
	"unicode/utf8"

	"github.com/bakins/simplegrpc"
	"google.golang.org/protobuf/proto"
)

const (
	spaceByte   = ' '
	tildeByte   = '~'
	percentByte = '%'
)

func encodeGrpcMessage(msg string) string {
	if msg == "" {
		return ""
	}
	lenMsg := len(msg)
	for i := 0; i < lenMsg; i++ {
		c := msg[i]
		if !(c >= spaceByte && c <= tildeByte && c != percentByte) {
			return encodeGrpcMessageUnchecked(msg)
		}
	}
	return msg
}

func encodeGrpcMessageUnchecked(msg string) string {
	var buf bytes.Buffer
	for len(msg) > 0 {
		r, size := utf8.DecodeRuneInString(msg)
		for _, b := range []byte(string(r)) {
			if size > 1 {
				// If size > 1, r is not ascii. Always do percent encoding.
				buf.WriteString(fmt.Sprintf("%%%02X", b))
				continue
			}

			// The for loop is necessary even if size == 1. r could be
			// utf8.RuneError.
			//
			// fmt.Sprintf("%%%02X", utf8.RuneError) gives "%FFFD".
			if b >= spaceByte && b <= tildeByte && b != percentByte {
				buf.WriteByte(b)
			} else {
				buf.WriteString(fmt.Sprintf("%%%02X", b))
			}
		}
		msg = msg[size:]
	}
	return buf.String()
}

{{ $package := .Name }}

{{ range $service := .Services }}
type {{ .GoName }}GRPCService interface {
	{{range $method := .Methods }}	
	{{ .GoName}}(context.Context, *{{ .Input }}) (*{{ .Output }}, error)
	{{ end }}
} 

type {{ .GoName }}GRPCHandler interface {
	http.Handler
	PathPrefix() string
}

type {{ .GoName }}GRPCServer struct {
	implementation {{ .GoName }}GRPCService
	interceptor simplegrpc.Interceptor
	handlers map[string]http.Handler
	pathPrefix string
}

var _ {{ .GoName }}GRPCHandler = &{{ .GoName }}GRPCServer{}

func New{{ .GoName }}GRPCServer(implementation {{ .GoName }}GRPCService, opts ...simplegrpc.ServerOption) *{{ .GoName }}GRPCServer {
	serverOpts := simplegrpc.ServerOptions{}

	for _, o := range opts {
		o(&serverOpts)
	}

	panicInterceptor := func(method simplegrpc.Method) simplegrpc.Method {
		return func(ctx context.Context, request interface{}) (resp interface{}, err error) {
			defer func() {
				if r := recover(); r != nil {
					perr, ok := r.(error)
					if !ok {
						perr = fmt.Errorf("panic: %v", perr)
					}

					err = simplegrpc.NewError(simplegrpc.Internal, perr.Error())
					
				}
			}()
	
			resp, err = method(ctx, request)
			return resp, err
		}
	}

	contextInterceptor := func(method simplegrpc.Method) simplegrpc.Method {
		return func(ctx context.Context, request interface{}) (interface{}, error) {
			resp, err := method(ctx, request)

			if err != nil {
				if errors.Is(err, context.Canceled) {
					return nil, simplegrpc.NewError(simplegrpc.Canceled, "context cancelled")
				}

				if errors.Is(err, context.DeadlineExceeded) {
					return nil, simplegrpc.NewError(simplegrpc.DeadlineExceeded, "context deadline exceeded")
				}

				return nil, err
			}

			return resp, nil
		}
	}

	interceptors := []simplegrpc.Interceptor {
		panicInterceptor,
		contextInterceptor,
	}

	interceptors = append(interceptors, serverOpts.Interceptors...) 
	
	s:= &{{ .GoName }}GRPCServer{
		implementation: implementation,
		interceptor: simplegrpc.ChainInterceptors(interceptors...),
		handlers: map[string]http.Handler{},
		pathPrefix: path.Clean(path.Join("/", "{{ $package }}.{{ .Name }}")) + "/",
	}

	{{range $method := .Methods }}
	s.handlers["{{ .Name }}"] = http.HandlerFunc(s.call{{ .Name }})
	{{ end }}
	
	return s
}

func(s *{{ .GoName }}GRPCServer)PathPrefix() string {
	return s.pathPrefix
}

// send an error with no body
func(s *{{ .GoName }}GRPCServer)serveError(err error, w http.ResponseWriter, contentType string) {
	w.Header().Set("Content-Type", contentType)
	w.Header().Add("Trailer", "grpc-status, grpc-message")
	w.WriteHeader(http.StatusOK)

	g, ok := err.(simplegrpc.Error)
	if !ok {
		g = simplegrpc.NewError(simplegrpc.Internal, err.Error())
	}

	w.Header().Set("grpc-status", strconv.Itoa(int(g.Code())))
	w.Header().Set("grpc-message", encodeGrpcMessage(g.Message()))
}

func(s *{{ .GoName }}GRPCServer)ServeHTTP(w http.ResponseWriter, r *http.Request) {
	ctx := simplegrpc.WithPackageName(r.Context(), "{{ $package }}")
	ctx = simplegrpc.WithServiceName(ctx, "{{ .Name }}")

	method := strings.TrimPrefix(r.URL.Path, s.pathPrefix)
	if method == "" {
		http.Error(w, "empty method name", http.StatusBadRequest)
		return
	}

	ctx = simplegrpc.WithMethodName(ctx, method)

	handler, ok := s.handlers[method]
	if !ok {
		http.Error(w, "no handler for method", http.StatusNotFound)
		return
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

{{range $method := .Methods }}	

func (s *{{ $service.GoName }}GRPCServer)call{{ $method.GoName }}(w http.ResponseWriter, r *http.Request) {
	ct := r.Header.Get("Content-Type")

	switch ct {
	case "application/grpc", "application/grpc+proto":
	default:
		e := simplegrpc.Errorf(simplegrpc.Unimplemented, "unsupported content-type %q", ct)
		s.serveError(e, w, ct)
		return
	}

	// does not support compression currently
	prefix := []byte{0,0,0,0,0}
	if _, err := io.ReadFull(r.Body, prefix); err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to read message prefix: %v", err)
		s.serveError(e, w, ct)
		return
	}

	// TODO: check for message too large

	length := binary.BigEndian.Uint32(prefix[1:])
	body := make([]byte, length)

	if _, err := io.ReadFull(r.Body, body); err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to read message: %v", err)
		s.serveError(e, w, ct)
		return
	}

	ctx := r.Context()
	reqContent := &{{ $method.Input }}{}

	u := proto.UnmarshalOptions{DiscardUnknown: true}
	if err := u.Unmarshal(body, reqContent); err != nil {
		e := simplegrpc.Errorf(simplegrpc.InvalidArgument, "failed to unmarshal request body: %v", err)
		s.serveError(e, w, ct)
		return
	}

	handler := func(ctx context.Context, req *{{ $method.Input }}) (*{{ $method.Output }}, error) {
		resp, err := s.interceptor(
			func(ctx context.Context, req interface{}) (interface{}, error) {
				typedReq, ok := req.(*{{ $method.Input }})
				if !ok {
					return nil, simplegrpc.NewError(simplegrpc.Internal, "failed type assertion req.(*{{ $method.Input }}) when calling interceptor")
				}
				return s.implementation.{{ $method.GoName }}(ctx, typedReq)
			},
		)(ctx, req)
		if resp != nil {
			typedResp, ok := resp.(*{{ $method.Output }})
			if !ok {
				return nil, simplegrpc.NewError(simplegrpc.Internal, "failed type assertion resp.(*{{ $method.Output }}) when calling interceptor")
			}
			return typedResp, err
		}
		return nil, err
	}

	respContent, err := handler(ctx, reqContent)

	if respContent == nil && err == nil {
		e := simplegrpc.NewError(simplegrpc.Internal, "received a nil *{{ $method.Output }} and nil error while calling {{ $method.GoName }}. nil responses are not supported")
		s.serveError(e, w, ct)
		return
	}

	if err != nil {
		s.serveError(err, w, ct)
		return
	}

	// TODO: check for message too large
	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		e := simplegrpc.Errorf(simplegrpc.Internal, "failed to unmarshal request body: %v", err)
		s.serveError(e, w, ct)
		return
	}

	// does not support compression currently
	prefix = []byte{0,0,0,0,0}
	binary.BigEndian.PutUint32(prefix[1:], uint32(len(respBytes)))

	w.Header().Set("Content-Type", ct)
	w.Header().Add("Trailer", "grpc-status, grpc-message")
	w.WriteHeader(http.StatusOK)

	if _, err := w.Write(prefix); err != nil {
		fmt.Println("failed to write prefix", err)
		return
	}

	if _, err := w.Write(respBytes) ; err != nil {
		fmt.Println("failed to write message", err)
		return
	}

	w.Header().Set("grpc-status", "0")
	w.Header().Set("grpc-message", "OK")
}
{{ end }}

type {{ .GoName }}GRPCClient struct {
	interceptor simplegrpc.Interceptor
	client *http.Client
	request *http.Request 
}

func New{{ $service.GoName }}GRPCClient(endpoint string, transport http.RoundTripper) (*{{ $service.GoName }}GRPCClient, error) {
	if transport == nil {
		transport = http.DefaultTransport
	}

	client := http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
		Transport: transport,
	}

	request, err := http.NewRequest(http.MethodPost, endpoint, nil)
	if err != nil {
		return nil, err
	}

	c := {{ $service.GoName }}GRPCClient {
		client: &client,
		request: request,
	}

	return &c, nil
}

{{range $method := .Methods }}	
func (s *{{ $service.GoName }}GRPCClient){{ $method.GoName }}(ctx context.Context, input *{{ $method.Input}}) (*{{ $method.Output }}, error){
	request := s.request.Clone(ctx)
	request.ContentLength = -1

	body, err := proto.Marshal(input)
	if err != nil {
		return nil, err
	}

	// does not support compression currently
	prefix := []byte{0,0,0,0,0}
	binary.BigEndian.PutUint32(prefix[1:], uint32(len(body)))

	buff := bytes.NewBuffer(nil)
	buff.Grow(len(prefix)+len(body))

	if _, err := buff.Write(prefix); err != nil {
		return nil, err
	}
	
	if _, err := buff.Write(body); err != nil {
		return nil, err
	}

	request.Body = ioutil.NopCloser(buff)

	resp, err := s.client.Do(request)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		// TODO: read some of the body for the error
		return nil, fmt.Errorf("unexpected HTTP status code %d", resp.StatusCode)
	}

	//check header for status
	// read body
	// check trailer

	return nil, nil
}
{{ end }}

{{ end }}
